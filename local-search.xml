<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/Java/%E7%AE%97%E6%B3%95/Dijkstra%20%E7%AE%97%E6%B3%95/"/>
    <url>/2025/03/23/Java/%E7%AE%97%E6%B3%95/Dijkstra%20%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><ol><li>定义</li></ol><ul><li><p>Dijkstra 算法是一种用于计算图中单源最短路径的算法，本质上是一个经过特殊改造的 BFS 算法，改造点有两个：</p><ol><li><p>使用 优先级队列，而不是普通队列进行 BFS 算法</p></li><li><p>添加了一个备忘录，记录起点到每个可达节点的最短路径权重和。</p></li></ol></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/Java/%E7%AE%97%E6%B3%95/Prim%E7%AE%97%E6%B3%95/"/>
    <url>/2025/03/23/Java/%E7%AE%97%E6%B3%95/Prim%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>1. </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/Java/%E7%AE%97%E6%B3%95/Kruskal%20%E7%AE%97%E6%B3%95/"/>
    <url>/2025/03/23/Java/%E7%AE%97%E6%B3%95/Kruskal%20%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><ol><li>最小生成树定义</li></ol><ul><li><p>那么什么是图的「⽣成树」呢，其实按字⾯意思也好理解，就是在图中找⼀棵包含图中的所有节点的树。专业点说，⽣成树是含有图中所有顶点的「⽆环连通⼦图」。</p></li><li><p>那么最⼩⽣成树很好理解了，所有可能的⽣成树中，权重和最⼩的那棵⽣成树就叫「最⼩⽣成树」。</p></li></ul><ol start="2"><li>代码实现</li></ol><ul><li><p>简单来说即为并查集加排序</p></li><li><pre><code class="language-java">class UF&#123;    private int count;    private int[] parent;    public UF(int n)&#123;        parent=new int[n];        this.count=n;    &#125;    public void union(int p,int q)&#123;        int rootp=find(p);        int rootq=find(q);        if(rootp==rootq)&#123;            return;        &#125;        parent[rootp]=rootq;        count--;    &#125;    public boolean connected(int p,int q)&#123;        int rootp=find(p);        int rootq=find(q);        return rootp==rootq;    &#125;    public int find(int x)&#123;        while(parent[x]!=x)&#123;            parent[x]=parent[parent[x]];            x=parent[x];        &#125;        return x;    &#125;    public int count()&#123;        return count;    &#125;&#125;int minimumCost(int n,int[][] connections)&#123;    UF uf=new UF(n+1);    Arrays.sort(connections,(a,b)-&gt;(a[2]-b[2]));    int sum=0;    for(int[] edge:connections)&#123;        int u=edge[0];        int v=edge[1];        int weight=edge[2];        if(uf.connected(u,v))&#123;            continue;        &#125;        sum+=weight;        uf.union(u,v);    &#125;    return uf.count()==2?sum:-1;&#125;</code></pre></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/Java/%E7%AE%97%E6%B3%95/Union%20Find%20%E7%AE%97%E6%B3%95/"/>
    <url>/2025/03/23/Java/%E7%AE%97%E6%B3%95/Union%20Find%20%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Union-Find-算法"><a href="#Union-Find-算法" class="headerlink" title="Union Find 算法"></a>Union Find 算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UF</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] parent;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">UF</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>parent=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><span class="hljs-built_in">this</span>.count=n;<br><span class="hljs-keyword">for</span>(inti=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>parent[i]=i;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span>&#123;<br><span class="hljs-type">int</span> rootp=find(p);<br><span class="hljs-type">int</span> rootq=find(q);<br><span class="hljs-keyword">if</span>(rootp==rootq)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>parent[rootp]=rootq;<br>count--;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">connected</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span>&#123;<br><span class="hljs-type">int</span> rootp=find(p);<br><span class="hljs-type">int</span> rootq=find(q);<br><span class="hljs-keyword">if</span>(rootp==rootq)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span>&#123;<br><span class="hljs-keyword">while</span>(parent[p]!=p)&#123;<br>parent[p]=parent[parent[p]];<br>p=parent[p];<br>&#125;<br><br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> count;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A/"/>
    <url>/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h2 id="二分图判定"><a href="#二分图判定" class="headerlink" title="二分图判定"></a>二分图判定</h2><ol><li>定义</li></ol><ul><li>⼆分图的顶点集可分割为两个互不相交的⼦集，图中每条边依附的两个顶点都分属于这两个⼦集，且两个⼦集内的顶点不相邻。</li></ul><ol start="2"><li>DFS解决</li></ol><ul><li><pre><code class="language-java">private boolean res;private boolean[] color;private boolean[] isVisited;public boolean isBipartite(int[][] graph)&#123;    res=true;    color=new boolean[graph.length];    isVisited=new boolean[graph.length];    for(int i=0;i&lt;graph.length;i++)&#123;        if(!isVisited[i])&#123;            traverse(graph,i);        &#125;    &#125;    return res;&#125;public void traverse(int[][] graph,int v)&#123;    if(!res) return;    isVisited[v]=true;    for(int w:graph[v])&#123;        if(!isVisited[w])&#123;            color[w]=!color[v];            traverse(graph,w);        &#125;else&#123;            if(color[w]==color[v])&#123;                res=false;            &#125;        &#125;    &#125;&#125;<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs processing"><br><span class="hljs-number">3.</span> BFS<br><br>- ```java<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> res;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] <span class="hljs-type">color</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] isVisited;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span>(<span class="hljs-type">int</span>[][] graph)&#123;<br>  res=<span class="hljs-literal">true</span>;<br>  <span class="hljs-type">color</span>=<span class="hljs-keyword">new </span><span class="hljs-class title_">boolean</span>[graph.<span class="hljs-property">length</span>];<br>  isVisited=<span class="hljs-keyword">new </span><span class="hljs-class title_">boolean</span>[graph.<span class="hljs-property">length</span>];<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;graph.<span class="hljs-property">length</span>;i++)&#123;<br>  <span class="hljs-keyword">if</span>(!isVisited[i])&#123;<br>  <span class="hljs-title function_">bfs</span>(graph,i);<br>  &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-type">int</span>[][] graph,<span class="hljs-type">int</span> v)&#123;<br>  Queue&lt;Integer&gt; q=<span class="hljs-keyword">new </span><span class="hljs-class title_">LinkedList</span>&lt;&gt;();<br>  q.<span class="hljs-property">offer</span>(v);<br>  isVisited[v]=<span class="hljs-literal">true</span>;<br><br>  <span class="hljs-keyword">while</span>(!q.<span class="hljs-property">isEmpty</span>()&amp;&amp;!res)&#123;<br>  <span class="hljs-type">int</span> cur=q.<span class="hljs-property">poll</span>();<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w:graph[v])&#123;<br>  <span class="hljs-keyword">if</span>(!isVisited[w])&#123;<br>  <span class="hljs-type">color</span>[w]=!<span class="hljs-type">color</span>[cur];<br>  isVisited[w]=<span class="hljs-literal">true</span>;<br>  q.<span class="hljs-property">offer</span>(w);<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-type">color</span>[w]==<span class="hljs-type">color</span>[cur])&#123;<br>  res=<span class="hljs-literal">false</span>;<br>  &#125;<br>  &#125;<br>  &#125;<br>  &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E7%8E%AF%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E7%8E%AF%E6%A3%80%E6%B5%8B%E5%8F%8A%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="环检测及拓扑排序算法"><a href="#环检测及拓扑排序算法" class="headerlink" title="环检测及拓扑排序算法"></a>环检测及拓扑排序算法</h2><ol start="0"><li>建图算法</li></ol><ul><li><p>邻接表</p><ul><li><pre><code class="language-java">List&lt;Integer&gt;[] buildGraph(int numCount,int[][] prerequisites)&#123;    List&lt;Integer&gt;[] graph=new LinkedList[numCount];    for(int i=0;i&lt;numCount;i++)&#123;        graph[i]=new LinkedList&lt;&gt;();    &#125;    for(edge[]:prerequisites)&#123;        int form=edge[1];        int to=edge[0];        graph[from].add(to);    &#125;    return graph;&#125; <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><br><span class="hljs-number">1.</span> 环检测算法<br><br>- DFS<br><br>- ```java<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span>[] onPath;<br>  <span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span>[] isVisited;<br>  <span class="hljs-built_in">boolean</span> hasCycle;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> canFinish(<span class="hljs-built_in">int</span> numCourses, <span class="hljs-built_in">int</span>[][] prerequisites)&#123;<br>  List&lt;Integer&gt;[] graph=buildGraph(numCourses,prerequisites);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;numCourses;i++)&#123;<br>  tarverse(graph,i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> !hasCycle;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> traverse(List&lt;Integer&gt;[] graph,<span class="hljs-built_in">int</span> s)&#123;<br>  <span class="hljs-keyword">if</span>(hasCycle)&#123;<br>  <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(onPath[s])&#123;<br>  hasCycle=<span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(isVisited[s])&#123;<br>  <span class="hljs-keyword">return</span>;<br>  &#125;<br>  onPath[s]=<span class="hljs-literal">true</span>;<br>  isVisited[s]=<span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> <span class="hljs-keyword">next</span>:graph[s])&#123;<br>  traverse(graph,<span class="hljs-keyword">next</span>);<br>  &#125;<br>  onPath[s]=<span class="hljs-literal">false</span>;<br>  &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>BFS</p><ul><li><pre><code class="language-java">public boolean canFinish(int numCourse,int[][] prerequisites)&#123;    List&lt;Integer&gt;[] graph=buildGraph(prerequisites);    int[] indegree=new int[numCourse];    for(int[] edge:prerequisites)&#123;        int from=int[1],to=int[0];        indegree[to]++;    &#125;    Queue&lt;Integer&gt; q=new LinkedList&lt;&gt;();    for(int i=0;i&lt;numCourse;i++)&#123;        if(indegree[i]==0)&#123;            q.offer(i);        &#125;    &#125;    int count=0;    while(!q.isEmpty())&#123;        int cur=q.poll();        count++;        for(int next:graph[cur])&#123;            indegree[next]--;            if(indegree[next]==0)&#123;                q.offer(next);            &#125;        &#125;    &#125;    return count==numCourse;&#125;<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><br><span class="hljs-number">2.</span> 拓扑排序算法<br><br>- DFS<br><br>- ```java<br>  <span class="hljs-comment">//记录的为结果的倒序</span><br>  <span class="hljs-comment">//需要使用Collections.reverse()</span><br>  <span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-keyword">order</span>=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> traverse(List&lt;Integer&gt;[] graph,<span class="hljs-built_in">int</span> s)&#123;<br>  <span class="hljs-keyword">if</span>(hasCycle)&#123;<br>  <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(onPath[s])&#123;<br>  hasCycle=<span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(isVisited[s])&#123;<br>  <span class="hljs-keyword">return</span>;<br>  &#125;<br>  onPath[s]=<span class="hljs-literal">true</span>;<br>  isVisited[s]=<span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> <span class="hljs-keyword">next</span>:graph[s])&#123;<br>  traverse(graph,<span class="hljs-keyword">next</span>);<br>  &#125;<br>  <span class="hljs-keyword">order</span>.add(s);<br>  onPath[s]=<span class="hljs-literal">false</span>;<br>  &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>BFS</p><ul><li><pre><code class="language-java">      public int[] canFinish(int numCourse,int[][] prerequisites)&#123;    List&lt;Integer&gt;[] graph=buildGraph(prerequisites);    int[] indegree=new int[numCourse];    for(int[] edge:prerequisites)&#123;        int from=int[1],to=int[0];        indegree[to]++;    &#125;    Queue&lt;Integer&gt; q=new LinkedList&lt;&gt;();    for(int i=0;i&lt;numCourse;i++)&#123;        if(indegree[i]==0)&#123;            q.offer(i);        &#125;    &#125;    int count=0;    int[] res=new int[numCourse];    while(!q.isEmpty())&#123;        int cur=q.poll();        res[count]=cur;        count++;        for(int next:graph[cur])&#123;            indegree[next]--;            if(indegree[next]==0)&#123;                q.offer(next);            &#125;        &#125;    &#125;    if(count!=numCourse)&#123;        return new int[];    &#125;    return res;&#125;</code></pre></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <url>/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="实现计算器"><a href="#实现计算器" class="headerlink" title="实现计算器"></a>实现计算器</h2><ol><li>层层分解-解决加减法</li></ol><ul><li><pre><code class="language-java">public int cal(List&lt;Character&gt; s)&#123;    List&lt;Integer&gt; stack=new Array    int num=0;    char sign=&#39;+&#39;;    while(!s.isEmpty())&#123;        char c=s.remove(0);        if(Character.isDigit(c))&#123;            num+=num*10+(c-&#39;0&#39;);        &#125;        if(!Character.isDigit(c)||s.isEmpty())&#123;             switch(sign)&#123;                case &#39;+&#39;:                    stack.add(num);                    break;                case &#39;-&#39;:                    stack.add(-num);                    break;            &#125;            sign=c;            num=0;        &#125;    &#125;    int sum=0;    for(int i:stack)&#123;        sum+=i;    &#125;    return sum;&#125;<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>2. 层层分解-解决乘除<br><br>- ```java<br>  public int cal(List&lt;Character&gt; s)&#123;<br>  List&lt;Integer&gt; <span class="hljs-attribute">stack</span>=new Array<br>  int <span class="hljs-attribute">num</span>=0;<br>  char <span class="hljs-attribute">sign</span>=<span class="hljs-string">&#x27;+&#x27;</span>;<br><br>  <span class="hljs-keyword">while</span>(!s.isEmpty())&#123;<br>  char <span class="hljs-attribute">c</span>=s.remove(0);<br>  <span class="hljs-keyword">if</span>(Character.isDigit(c))&#123;<br>  num+=num<span class="hljs-number">*10</span>+(c-<span class="hljs-string">&#x27;0&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(!Character.isDigit(c)||s.isEmpty())&#123;<br>   switch(sign)&#123;<br>  case <span class="hljs-string">&#x27;+&#x27;</span>:<br>  stack.<span class="hljs-built_in">add</span>(num);<br>  break;<br>  case <span class="hljs-string">&#x27;-&#x27;</span>:<br>  stack.<span class="hljs-built_in">add</span>(-num);<br>  break;<br>  case <span class="hljs-string">&#x27;*&#x27;</span>:<br>  stack.<span class="hljs-built_in">set</span>(stack.size()-1,stack.<span class="hljs-built_in">get</span>(stack.size()-1)*num);<br>  break;<br>  case <span class="hljs-string">&#x27;/&#x27;</span>:<br>  stack.<span class="hljs-built_in">set</span>(stack.size()-1,stack.<span class="hljs-built_in">get</span>(stack.size()-1)/num);<br>  break;<br>  &#125;<br>  <span class="hljs-attribute">sign</span>=c;<br>  <span class="hljs-attribute">num</span>=0;<br>  &#125;<br>  &#125;<br>  int <span class="hljs-attribute">sum</span>=0;<br>  <span class="hljs-keyword">for</span>(int i:stack)&#123;<br>  sum+=i;<br>  &#125;<br>  return sum;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul><ol start="3"><li>层层分解-解决括号</li></ol><ul><li><pre><code class="language-java">  private int helper(List&lt;Character&gt; s) &#123;      List&lt;Integer&gt; stack = new ArrayList&lt;&gt;();      char sign = &#39;+&#39;;      int num = 0;      while (!s.isEmpty()) &#123;          char c = s.remove(0);          if (Character.isDigit(c)) &#123;              num = 10 * num + (c - &#39;0&#39;);          &#125;          if (c == &#39;(&#39;) &#123;              num = helper(s);          &#125;          if ((!Character.isDigit(c) &amp;&amp; c != &#39; &#39;) || s.isEmpty()) &#123;              switch (sign) &#123;                  case &#39;+&#39;:                      stack.add(num);                      break;                  case &#39;-&#39;:                      stack.add(-num);                      break;                  case &#39;*&#39;:                      stack.set(stack.size() - 1, stack.get(stack.size() - 1) * num);                      break;                  case &#39;/&#39;:                      stack.set(stack.size() - 1, (int) (stack.get(stack.size() - 1) / (double) num));                      break;              &#125;              num = 0;              sign = c;          &#125;          if (c == &#39;)&#39;) &#123;              break;          &#125;      &#125;      int sum = 0;      for (int n : stack) &#123;          sum += n;      &#125;      return sum;  &#125;</code></pre></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/Java/%E7%AE%97%E6%B3%95/LRU%E7%AE%97%E6%B3%95/"/>
    <url>/2025/03/23/Java/%E7%AE%97%E6%B3%95/LRU%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><ol><li>是什么</li></ol><ul><li><p>LRU（Least Recently Used）算法是一种用于缓存管理的算法，它的核心思想是基于“局部性原理”（Locality of Reference），即认为最近被访问过的数据很可能会在不久的将来再次被访问。LRU 算法通过维护一个最近访问的记录，淘汰最长时间未被访问的数据，以提高缓存的命中率。</p></li><li><p>简单来说即为最近最少使用原则</p></li></ul><ol start="2"><li>实现</li></ol><ul><li><p>思路</p><ul><li>使用hash+双向链表</li><li>哈希可以实现快速访问指定元素，双向链表可以实现快速删除</li></ul></li><li><p>实现</p><ul><li><pre><code class="language-java">//节点结构class Node&#123;    int key;    int val;    Node pre;    Node next;    public Node(int key,int val)&#123;        this.key=key;        this.val=val;    &#125;&#125;//链表构造class DoubleList&#123;    Node head;    Node tail;    int size;    public DoubleList()&#123;        head=new Node(0,0);        tail=new Node(0,0);        head.next=tail;        tail.pre=head;        size=0;    &#125;    public void addLast(Node x)&#123;        x.pre=tail.pre;        tail.pre.next=x;        x.next=tail;        tail.pre=x;        size++;    &#125;    //node x一定存在    public void remove(Node x)&#123;        x.next.pre=x.pre;        x.pre.next=x.next;        size--;    &#125;    public First removeFirst()&#123;        if(head.next==tail)&#123;            return null;        &#125;        Node first=head.next;        remove(first);        return first;    &#125;    public int size()&#123;        return size;    &#125;&#125;//LRU缓存cache构造class LRUCache&#123;    private HashMap&lt;Integer,Node&gt; map;    private DoubleList cache;    private int cap;    public LRUCache(int capacity)&#123;        this.cap=capacity;        map=new HashMap&lt;&gt;();        cache=new DoubleList();    &#125;    public void makeRecently(int key)&#123;        Node x=map.get(key);        cache.remove(key);        cache.addLast(key);    &#125;    public void addRecently(int key,int val)&#123;        Node x=new Node(key,val)        cache.addLast(x);        map.put(key,x);    &#125;    public void deleteKey(int key)&#123;        Node x=map.get(key);        cache.remove(x);        map.remove(key);    &#125;    public void removeLeastRecently()&#123;        Node x=cache.removeFirst();        map.remove(x.key);    &#125;    public int get(int key)&#123;        if(!map.containsKey(key))&#123;            return -1;        &#125;        Node x=map.get(key);        makeRecently(x);        return x.val;    &#125;    public void put(int key,int val)&#123;        if(map.containsKey(key))&#123;            deleteKey(key);            addRecently(key,val);            return;        &#125;        if(cap==cache.size())&#123;            removeLeastRecently();        &#125;        addRecently(key,val);    &#125;&#125;</code></pre></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><ol><li>特性</li></ol><ul><li>左小右大，中序结果为升序</li></ul><ol start="2"><li><p>增删改</p></li><li><p>构造</p></li></ol><ul><li><pre><code class="language-java">  // 备忘录  int[][] memo;     int numTrees(int n) &#123;      // 备忘录的值初始化为 0      memo = new int[n + 1][n + 1];      return count(1, n);  &#125;     int count(int lo, int hi) &#123;      if (lo &gt; hi) return 1;      // 查备忘录      if (memo[lo][hi] != 0) &#123;          return memo[lo][hi];      &#125;         int res = 0;      for (int mid = lo; mid &lt;= hi; mid++) &#123;          int left = count(lo, mid - 1);          int right = count(mid + 1, hi);          res += left * right;      &#125;      // 将结果存入备忘录      memo[lo][hi] = res;         return res;  &#125;<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>- ```java<br>  <span class="hljs-comment">/* 主函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title">generateTrees</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">// 构造闭区间 [1, n] 组成的 BST </span><br>    <span class="hljs-keyword">return</span> build(<span class="hljs-number">1</span>, n);<br>&#125;<br> <br><span class="hljs-comment">/* 构造闭区间 [lo, hi] 组成的 BST */</span><br><span class="hljs-function">List&lt;TreeNode&gt; <span class="hljs-title">build</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> lo, <span class="hljs-built_in">int</span> hi</span>)</span> &#123;<br>    List&lt;TreeNode&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (lo &gt; hi) &#123;<br>        res.<span class="hljs-keyword">add</span>(<span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br> <br>    <span class="hljs-comment">// 1、穷举 root 节点的所有可能。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = lo; i &lt;= hi; i++) &#123;<br>        <span class="hljs-comment">// 2、递归构造出左右子树的所有合法 BST。</span><br>        List&lt;TreeNode&gt; leftTree = build(lo, i - <span class="hljs-number">1</span>);<br>        List&lt;TreeNode&gt; rightTree = build(i + <span class="hljs-number">1</span>, hi);<br>        <span class="hljs-comment">// 3、给 root 节点穷举所有左右子树的组合。</span><br>        <span class="hljs-keyword">for</span> (TreeNode left : leftTree) &#123;<br>            <span class="hljs-keyword">for</span> (TreeNode right : rightTree) &#123;<br>                <span class="hljs-comment">// i 作为根节点 root 的值</span><br>                TreeNode root = <span class="hljs-keyword">new</span> TreeNode(i);<br>                root.left = left;<br>                root.right = right;<br>                res.<span class="hljs-keyword">add</span>(root);<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E8%8D%89%E7%A8%BF/"/>
    <url>/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E8%8D%89%E7%A8%BF/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3/"/>
    <url>/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<ol><li><p>分解</p><ul><li><pre><code class="language-java">// 分解问题的思路  class Solution &#123;      // 定义：输入一个节点，返回以该节点为根的二叉树的最大深度      public int maxDepth(TreeNode root) &#123;          if (root == null) &#123;              return 0;          &#125;          int leftMax = maxDepth(root.left);          int rightMax = maxDepth(root.right);          // 根据左右子树的最大深度推出原二叉树的最大深度          return 1 + Math.max(leftMax, rightMax);      &#125;  &#125;<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-number">2.</span> 遍历<br><br>- ```java<br>  <span class="hljs-comment">// 全排列算法主要结构</span><br><br><span class="hljs-comment">// 全局变量，存储 backtrack 函数的遍历状态</span><br>List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>List&lt;Integer&gt; track = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br><span class="hljs-comment">// 递归树遍历函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] nums, List&lt;Integer&gt; track</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (track.size() == nums.length) &#123;<br>        <span class="hljs-comment">// 到达叶子节点，收集结果</span><br>        res.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(track));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 做选择</span><br>        track.<span class="hljs-keyword">add</span>(nums[i]);<br><br>        backtrack(nums, track);<br><br>        <span class="hljs-comment">// 撤销选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>最近公共祖先系列解题框架</p><ul><li><pre><code class="language-java">      TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;      // base case      if (root == null) return null;      if (root == p || root == q) return root;            TreeNode left = lowestCommonAncestor(root.left, p, q);      TreeNode right = lowestCommonAncestor(root.right, p, q);      // 情况 1      if (left != null &amp;&amp; right != null) &#123;          return root;      &#125;      // 情况 2      if (left == null &amp;&amp; right == null) &#123;          return null;      &#125;      // 情况 3      return left == null ? right : left;  &#125;<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-number">4.</span> 如何计算完全二叉树的节点数<br><br>- ```java<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> root, r = root;<br>    <span class="hljs-comment">// 记录左、右子树的高度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hl</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, hr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (l != <span class="hljs-literal">null</span>) &#123;<br>        l = l.left;<br>        hl++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (r != <span class="hljs-literal">null</span>) &#123;<br>        r = r.right;<br>        hr++;<br>    &#125;<br>    <span class="hljs-comment">// 如果左右子树的高度相同，则是一棵满二叉树</span><br>    <span class="hljs-keyword">if</span> (hl == hr) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">2</span>, hl) - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果左右高度不同，则按照普通二叉树的逻辑计算</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + countNodes(root.left) + countNodes(root.right);<br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<ol><li><p>使用栈实现队列</p><ul><li>使用两个栈</li></ul></li><li><p>使用队列实现栈</p><ul><li>只使用一个队列，pop时将队列的元素弹出并压回队列</li></ul></li><li><p>括号题目</p><ul><li><p>判断有效括号串</p><ul><li>使用栈来存储左括号，为右括号提供最近的左括号做判断</li></ul></li><li><p>平衡括号串</p><ul><li><pre><code class="language-java">int minAddToMakeValid(string s)&#123;    int res=0;    int need=0;//维护右括号需求量    char[] c=s.toCharArray();    for(int i=0;i&lt;c.length;i++)&#123;        if(char[i]==&#39;(&#39;)&#123;            need++;        &#125;        if(char[i]==&#39;)&#39;)&#123;            need--;            if(need==-1)&#123;                ans++;                need=0;            &#125;        &#125;    &#125;    return ans+need;&#125;<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>- ![8d010b15d8fe60e2e7957860db847c12.png](<span class="hljs-built_in">..</span>/<span class="hljs-built_in">..</span>/_resources/8d010b15d8fe60e2e7957860db847c12.png)<br><br>- ```java<br>int minInsertions(string s)&#123;<br>int <span class="hljs-attribute">ans</span>=0;<br>int <span class="hljs-attribute">need</span>=0;<br>char[] <span class="hljs-attribute">c</span>=s.toCharArray();<br><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;c.length;i++)&#123;<br><span class="hljs-keyword">if</span>(c[i]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>need+=2;<br><span class="hljs-keyword">if</span>(need%<span class="hljs-attribute">2</span>==1)&#123;<br>ans++;<br>need--;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span>(c[i]==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>need--;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">need</span>==-1)&#123;<br>ans++;<br><span class="hljs-attribute">need</span>=1;<br>&#125;<br>&#125;<br>&#125;<br><br>return ans+need;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>括号题目框架</p></li><li><pre><code class="language-java">Stack&lt;Character&gt; stack=new Stack&lt;&gt;();int ans=0;char[] c=s.toCharArray();for(int i=0;i&lt;c.length;i++)&#123;    if(c[i]==&#39;(&#39;)&#123;        stack.push(i);    &#125;else&#123;        if(!stack.isEmpty())&#123;            char leftIndex=stack.pop();            int len=1+i-leftIndex;        &#125;else&#123;            //没有左括号处理        &#125;    &#125;&#125;<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br><span class="hljs-number">4.</span> 单调栈<br><br>- 一般用来解决下一个最大/最小问题<br>  <br>- ```java<br>  <span class="hljs-type">int</span>[] calculateGreaterElement(<span class="hljs-type">int</span>[] nums)&#123;<br>  <span class="hljs-type">int</span> n=nums.length;<br>  <span class="hljs-type">int</span>[] ans=<span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n];<br>  Stack&lt;<span class="hljs-type">Integer</span>&gt; s=<span class="hljs-built_in">new</span> Stack&lt;&gt;();<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i<span class="hljs-comment">--)&#123;</span><br>  <span class="hljs-keyword">while</span>(!s.isEmpty()&amp;&amp;s.peek()&lt;=nums[i])&#123;<br>  s.pop();<br>  &#125;<br><br>  ans[i]=s.isEmpty()?<span class="hljs-number">-1</span>:s.peek();<br><br>  s.push(nums[i<span class="hljs-number">-1</span>]);<br>  &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>环形数据求下一个最大-》拼接2倍原数组-》可以用%n实现</p></li></ul></li><li><p>单调队列</p><ul><li><pre><code class="language-java">// 单调队列的实现  class MonotonicQueue &#123;      LinkedList&lt;Integer&gt; maxq = new LinkedList&lt;&gt;();      public void push(int n) &#123;          // 将小于 n 的元素全部删除          while (!maxq.isEmpty() &amp;&amp; maxq.getLast() &lt; n) &#123;                maxq.pollLast();          &#125;          // 然后将 n 加入尾部          maxq.addLast(n);      &#125;            public int max() &#123;          return maxq.getFirst();      &#125;            public void pop(int n) &#123;          if (n == maxq.getFirst()) &#123;              maxq.pollFirst();          &#125;      &#125;  &#125;</code></pre></li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ol><li><p>归并排序代码框架</p><ul><li><pre><code class="language-java">privtate int[] temp;void sort(int[] nums)&#123;    temp=new int[nums.length];    sort(nums,0,nums.lenght-1);&#125;void sort(int[] nums,int left,int right)&#123;    if(left==right)&#123;        return;    &#125;    int mid=left+(right-left)/2;    sort(nums,left,mid);    sort(nums,mid+1,right);    merge(nums,left,mid,right);&#125;void merge(int[] nums,int left,int mid,int right)&#123;    for(int i=left;i&lt;=right;i++)&#123;        temp[i]=nums[i];    &#125;    int i=left;    int j=mid+1;    for(int p=left;p&lt;=right;p++)&#123;        if(i==mid+1)&#123;            nums[p]=temp[j++];        &#125;else if(j==right+1)&#123;            nums[p]=temp[i++];        &#125;else if(temp[i]&lt;temp[j])&#123;            nums[p]=temp[i++];        &#125;else if(temp[i]&gt;=temp[j])&#123;            nums[p]=temp[j++];        &#125;    &#125;&#125;</code></pre></li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"/>
    <url>/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="数组基本技巧"><a href="#数组基本技巧" class="headerlink" title="数组基本技巧"></a>数组基本技巧</h2><ol><li><p>快慢指针</p><ul><li>原地去除重复数组元素</li><li><pre><code class="language-java">public int removeDuplicates(int[] nums)&#123;    if(nums.length==0)&#123;        return nums;    &#125;    int fast,slow;    fast=slow=1;    while(fast&lt;nums.length)&#123;        if(nums[fast]!=nums[slow])&#123;            slow++;            nums[slow]=nums[fast];        &#125;        fast++;    &#125;    return slow+1;&#125;<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>- 原地删除元素<br>- ```<span class="hljs-function">java</span><br><span class="hljs-function">  <span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> val)</span></span>&#123;<br>  <span class="hljs-type">int</span> fast=<span class="hljs-number">0</span>,slow=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(fast&lt;nums.length)&#123;<br>  <span class="hljs-keyword">if</span>(nums[fast]!=val)&#123;<br>  nums[slow]=nums[fast];<br>  slow++;<br>  &#125;<br>  fast++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> slow;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>滑动窗口</p><ul><li><p>代码框架</p></li><li><pre><code class="language-java">// 滑动窗口算法伪码框架  void slidingWindow(String s) &#123;      // 用合适的数据结构记录窗口中的数据，根据具体场景变通      // 比如说，我想记录窗口中元素出现的次数，就用 map      // 如果我想记录窗口中的元素和，就可以只用一个 int      Object window = ...            int left = 0, right = 0;      while (right &lt; s.length()) &#123;          // c 是将移入窗口的字符          char c = s[right];                    // 增大窗口          right++;          // 进行窗口内数据的一系列更新          window.add(c)          ...            // *** debug 输出的位置 ***          // 注意在最终的解法代码中不要 print          // 因为 IO 操作很耗时，可能导致超时          printf(&quot;window: [%d, %d)\n&quot;, left, right);          // ***********************            // 判断左侧窗口是否要收缩          while (left &lt; right &amp;&amp; window needs shrink) &#123;              // d 是将移出窗口的字符              char d = s[left];                            // 缩小窗口              left++;              // 进行窗口内数据的一系列更新              window.remove(d)              ...          &#125;      &#125;  &#125;<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs excel"><br><span class="hljs-number">3</span>. 左右指针常用算法<br><br>- 二分查找框架<br>  <br>- ```java<br>  <span class="hljs-built_in">int</span> binarySearch(<span class="hljs-built_in">int</span>[] nums,<span class="hljs-built_in">int</span> target)&#123;<br>  <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>=<span class="hljs-number">0</span>,<span class="hljs-built_in">right</span>=nums.length-<span class="hljs-number">1</span>;<br><br>  while(<span class="hljs-built_in">left</span>&lt;=<span class="hljs-built_in">right</span>)&#123;<br>  <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span>=<span class="hljs-built_in">left</span>+(<span class="hljs-built_in">right</span>-<span class="hljs-built_in">left</span>)/<span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">if</span>(nums[<span class="hljs-built_in">mid</span>]==target)&#123;<br>  return <span class="hljs-built_in">mid</span>;<br>  &#125;else <span class="hljs-built_in">if</span>(nums[<span class="hljs-built_in">mid</span>]&lt;target)&#123;<br>  <span class="hljs-built_in">right</span>=<span class="hljs-built_in">mid</span>-<span class="hljs-number">1</span>;<br>  &#125;else <span class="hljs-built_in">if</span>(nums[<span class="hljs-built_in">mid</span>]&gt;target)&#123;<br>  <span class="hljs-built_in">left</span>=<span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span>;<br>  &#125;<br>  &#125;<br>  return -<span class="hljs-number">1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>二分搜索问题泛化</p></li><li><pre><code class="language-java">// 函数 f 是关于⾃变量 x 的单调函数  int f(int x) &#123;   // ...  &#125;  // 主函数，在 f(x) == target 的约束下求 x 的最值  int solution(int[] nums, int target) &#123;   if (nums.length == 0) return -1;   // 问⾃⼰：⾃变量 x 的最⼩值是多少？   int left = ...;   // 问⾃⼰：⾃变量 x 的最⼤值是多少？   int right = ... + 1;      while (left &lt; right) &#123;   int mid = left + (right - left) / 2;   if (f(mid) == target) &#123;   // 问⾃⼰：题⽬是求左边界还是右边界？   // ...   &#125; else if (f(mid) &lt; target) &#123;   // 问⾃⼰：怎么让 f(x) ⼤⼀点？   // ...   &#125; else if (f(mid) &gt; target) &#123;   // 问⾃⼰：怎么让 f(x) ⼩⼀点？   // ...   &#125;   &#125;   return left;  &#125;<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>- n数之和<span class="hljs-number">167</span>-两边向中<br> <br>- 反转数组<span class="hljs-number">344</span>-两边向中<br> <br>- 回文串判断-两边向中<br> <br>- 寻找最长回文串<span class="hljs-number">5</span>-中心扩散<br> <br>- ```<span class="hljs-function">java</span><br><span class="hljs-function">  <span class="hljs-type">String</span> <span class="hljs-title">palindrome</span><span class="hljs-params">(<span class="hljs-type">String</span> s,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(l&gt;=<span class="hljs-number">0</span>&amp;&amp;r&lt;s.<span class="hljs-built_in">length</span>()&amp;&amp;s.<span class="hljs-built_in">charAt</span>(l)==s.<span class="hljs-built_in">charAt</span>(r))&#123;<br>  l++;<br>  r--<br>  &#125;<br>  <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substring</span>(l<span class="hljs-number">+1</span>,r);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">String</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span></span>&#123;<br>  <span class="hljs-type">String</span> res=<span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();i++)&#123;<br>  <span class="hljs-type">String</span> s1=<span class="hljs-built_in">palindrome</span>(s,i,i);<br>  <span class="hljs-type">String</span> s2=<span class="hljs-built_in">palindrome</span>(s,i,i<span class="hljs-number">+1</span>);<br><br>  res=res.<span class="hljs-built_in">length</span>()&gt;s<span class="hljs-number">1.l</span>ength()?res:s1;<br>  res=res.<span class="hljs-built_in">length</span>()&gt;s<span class="hljs-number">2.l</span>ength()?res:s2;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>原地旋转二维矩阵数组48-翻转等效旋转</p></li><li><pre><code class="language-java">void rotate(int[][] matrix)&#123;    for(int i=0;i&lt;matrix.length;i++)&#123;        for(int j=i;j&lt;matrix.length;j++)&#123;            int temp = matrix[i][j];            matrix[i][j]=matrix[j][i];            matrix[j][i]=temp;        &#125;    &#125;    for(int[] row:matrix)&#123;        reverse(row);    &#125;&#125;void reverse(int[] arr)&#123;    int len=arr.length;    int i=0;    int j=len-1;    while(i&lt;j)&#123;        int temp=arr[i];        arr[i]=arr[j];        arr[j]=temp;        i++;        j--;    &#125;&#125;<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>- 螺旋遍历矩阵二维数组54，59-维护四边界<br> <br>- ```java<br>  List&lt;Integer&gt; spiralOrder(int[][] matrix)&#123;<br>  int <span class="hljs-attribute">m</span>=matrix.length;<br>  int <span class="hljs-attribute">n</span>=matrix[0].length;<br>  int <span class="hljs-attribute">upper_board</span>=0;<br>  int <span class="hljs-attribute">left_board</span>=0;<br>  int <span class="hljs-attribute">right_board</span>=n-1;<br>  int <span class="hljs-attribute">down_board</span>=m-1;<br>  List&lt;Integer&gt; <span class="hljs-attribute">ans</span>=new ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">while</span>(ans.size()&lt;m*n)&#123;<br>  <span class="hljs-keyword">if</span>(upper_board&lt;=down_board)&#123;<br>  <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=left_board;i&lt;=right_board;i++)&#123;<br>  ans.<span class="hljs-built_in">add</span>(matrix[upper_board][i]);<br>  &#125;<br>  upper_board++;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(left_board&lt;=right_board)&#123;<br>  <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=upper_board;i&lt;=down_board;i++)&#123;<br>  ans.<span class="hljs-built_in">add</span>(matrix[i][right_board]);<br>  &#125;<br>  right_board--;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(upper_board&lt;=down_board)&#123;<br>  <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=right_board;i&gt;=left_board;i--)&#123;<br>  ans.<span class="hljs-built_in">add</span>(matrix[down_board][i]);<br>  &#125;<br>  down_board--;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(left_board&lt;=right_board)&#123;<br>  <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=down_board;i&gt;=upper_board;i--)&#123;<br>  ans.<span class="hljs-built_in">add</span>(matrix[i][left_board]);<br>  &#125;<br>  left_board++;<br>  &#125;<br>  <br>  &#125;<br>  return ans;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>搜索二维矩阵240-选择一大一小的角度寻找，简化为一维问题</p></li></ul></li><li><p>多维坐标映射转换</p><ul><li><p>index&#x3D;i*n+j;</p></li><li><p>i&#x3D;index&#x2F;n; j&#x3D;index%n</p></li></ul></li><li><p>前缀和数组</p><ul><li><p>先构建前缀和数组，<code>pre[i]=pre[i-1]+nums[i-1];</code></p></li><li><p>一维前缀和</p></li><li><pre><code class="language-java">    class NumArray &#123;      // 前缀和数组      private int[] preSum;        // 输入一个数组，构造前缀和      public NumArray(int[] nums) &#123;          // preSum[0] = 0，便于计算累加和          preSum = new int[nums.length + 1];          // 计算 nums 的累加和          for (int i = 1; i &lt; preSum.length; i++) &#123;              preSum[i] = preSum[i - 1] + nums[i - 1];          &#125;      &#125;        // 查询闭区间 [left, right] 的累加和      public int sumRange(int left, int right) &#123;          return preSum[right + 1] - preSum[left];      &#125;  &#125;<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><br>- 二维前缀和<br> <br>- ```java<br>  class NumMatrix &#123;<br>    // preSum<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> 记录矩阵 <span class="hljs-comment">[0, 0, i-1, j-1]</span> 的元素和<br>    private int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> preSum;<br><br>    public NumMatrix(int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> matrix) &#123;<br>        int m = matrix.length, n = matrix<span class="hljs-comment">[0]</span>.length;<br>        if (m == 0 || n == 0) return;<br>        // 构造前缀和矩阵<br>        preSum = new int<span class="hljs-comment">[m + 1]</span><span class="hljs-comment">[n + 1]</span>;<br>        for (int i = 1; i &lt;= m; i++) &#123;<br>            for (int j = 1; j &lt;= n; j++) &#123;<br>                // 计算每个矩阵 <span class="hljs-comment">[0, 0, i, j]</span> 的元素和<br>                preSum<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = preSum<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span> + preSum<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span> + matrix<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j - 1]</span> - preSum<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-1]</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    // 计算子矩阵 <span class="hljs-comment">[x1, y1, x2, y2]</span> 的元素和<br>    public int sumRegion(int x1, int y1, int x2, int y2) &#123;<br>        // 目标矩阵之和由四个相邻矩阵运算获得<br>        return preSum<span class="hljs-comment">[x2+1]</span><span class="hljs-comment">[y2+1]</span> - preSum<span class="hljs-comment">[x1]</span><span class="hljs-comment">[y2+1]</span> - preSum<span class="hljs-comment">[x2+1]</span><span class="hljs-comment">[y1]</span> + preSum<span class="hljs-comment">[x1]</span><span class="hljs-comment">[y1]</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>差分数组</p><ul><li><p>代码模板</p></li><li><pre><code class="language-java">class Difference&#123;    private int[] diff;    public Difference(int[] nums)&#123;        assert nums.length&gt;0;        diff=new int[nums.length];        diff[0]=nums[0];        for(int i=1;i&lt;nums.length;i++)&#123;            diff[i]=nums[i]-nums[i-1];        &#125;    &#125;    public void increment(int i,int j,int val)&#123;        diff[i]+=val;        if(j+1&lt;diff.length)&#123;            diff[j]-=val;        &#125;    &#125;    public int[] result()&#123;        int[] ans=new int[diff.length];        ans[0]=diff[0];        for(int i=1;i&lt;diff.length;i++)&#123;            ans[i]=ans[i-1]+diff[i];        &#125;        return ans;    &#125;&#125;</code></pre></li><li></li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
    <url>/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="单链表基本技巧"><a href="#单链表基本技巧" class="headerlink" title="单链表基本技巧"></a>单链表基本技巧</h2><ol><li><p>判断回文串</p><ul><li>技巧一：反转链表</li><li><pre><code class="language-java">LinkNode reverse(LinkNode head)&#123;    LinkNode pre=null;    LinkNode cur=head;    while(cur!=null)&#123;        LinkNode next=cur.next;        cur.next=pre;        pre=cur;        cur=next;    &#125;    return pre;&#125;<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xquery">- 技巧二：递归框架<br>- 脱胎于二叉树前中后序遍历特点<br>- ```java<br>  LinkNode<span class="hljs-built_in"> reverse</span>(LinkNode<span class="hljs-built_in"> head</span>)&#123;<br>  <span class="hljs-keyword">if</span><span class="hljs-built_in">(head</span>==null|<span class="hljs-built_in">|head</span>.<span class="hljs-keyword">next</span>==null)&#123;<br>  <span class="hljs-keyword">return</span><span class="hljs-built_in"> head</span>;<br>  &#125;<br><br>  LinkNode<span class="hljs-built_in"> last</span><span class="hljs-built_in">=reverse</span><span class="hljs-built_in">(head</span>.<span class="hljs-keyword">next</span>);<br> <span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span><span class="hljs-built_in">=head</span>;<br> <span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>=null;<br>  <span class="hljs-keyword">return</span><span class="hljs-built_in"> last</span>;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li>技巧三：快慢指针</li><li><pre><code class="language-java">LinkNode slow,fast;slow=fast=head;while(fast!=null&amp;&amp;fast.next!=null)&#123;    slow=slow.next;    fast=fast.next.next;&#125;</code></pre></li></ul></li><li><p>快慢指针</p><ul><li>链表环判断</li><li>倒数第k个链表节点</li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E5%9B%BE%E7%BB%93%E6%9E%84%E5%8F%8A%E9%80%9A%E7%94%A8%E4%BB%A3%E7%A0%81/"/>
    <url>/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E5%9B%BE%E7%BB%93%E6%9E%84%E5%8F%8A%E9%80%9A%E7%94%A8%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h2><ol><li><p>逻辑结构</p><ul><li><p>由节点和边构成</p></li><li><pre><code class="hljs">class Vertex &#123;    int id;    Vertex[] neighbors;<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code"></span><br><span class="hljs-code">2. 常用表示(无权图)</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">-</span> 邻接表<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">`List&lt;Integer&gt;[] graph`</span><br><br><span class="hljs-bullet">-</span> 邻接矩阵<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">`boolean[][] matrix`</span><br><br><span class="hljs-bullet">3.</span> 常用表示(有全图)<br><br><span class="hljs-bullet">-</span> 邻接表<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">`List&lt;int[]&gt;[] graph`</span><br><br><span class="hljs-bullet">-</span> 邻接矩阵<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">`int[][] matrix`</span><br><br><span class="hljs-section">## 通用代码</span><br><br><span class="hljs-bullet">1.</span> 遍历(DFS)<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">```java</span><br><span class="hljs-code">  boolean[] isVisited;</span><br><span class="hljs-code">  boolean[] onPath;</span><br><span class="hljs-code">  void traverse(Graph graph,int s)&#123;</span><br><span class="hljs-code"> if(isVisted[s]) return;</span><br><span class="hljs-code"> isVisited[s]=true;</span><br><span class="hljs-code"> onPath[s]=true;</span><br><span class="hljs-code"> for(int neighbor:graph.neighbors(s))&#123;</span><br><span class="hljs-code"> traverse(graph,neighbor);</span><br><span class="hljs-code"> &#125;</span><br><span class="hljs-code"> onPath[s]=false;</span><br><span class="hljs-code">  &#125;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>dijkstra</p><ul><li><p>辅助类（包含节点，权重和信息）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span>&#123;<br><span class="hljs-type">int</span> val;<br><span class="hljs-type">int</span> distFromStart;<br><span class="hljs-comment">//构造方法略</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>dijkstra伪代码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">weight</span><span class="hljs-params">(<span class="hljs-type">int</span> from,<span class="hljs-type">int</span> to)</span>;<br>List&lt;Integer&gt; <span class="hljs-title function_">adj</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span>;<br><span class="hljs-type">int</span>[] dijkstra(<span class="hljs-type">int</span> start,List&lt;Integer&gt;[] graph)&#123;<br><span class="hljs-type">int</span> V=graph.length;<br><span class="hljs-type">int</span>[] distTo=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[V];<br>Arrays.fill(distTo,Integer.MAX_VALUE);<br>distTo[start]=<span class="hljs-number">0</span>;<br>Queue&lt;State&gt; pq=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;&#123;<br><span class="hljs-keyword">return</span> a.distFromStart-b.distFromStart;<br>&#125;);<br>pq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>(start,<span class="hljs-number">0</span>));<br><span class="hljs-keyword">while</span>(!pq.isEmpty())&#123;<br><span class="hljs-type">State</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> pq.poll();<br><span class="hljs-keyword">if</span>(cur.distFromStart&gt;distTo[cur.val])&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s : adj(cur.val))&#123;<br><span class="hljs-type">int</span> distToNextNode=distTo[cur.val]+weight(cur.val,s);<br><span class="hljs-keyword">if</span>(distTo[s]&gt;distToNextNode)&#123;<br>distTo[s]=distToNextNode;<br>pq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>(s,distToNextNode));<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> distTo;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>例题</p><p>  <img src="/2025/03/23/Java/%E7%AE%97%E6%B3%95/%E5%9B%BE%E7%BB%93%E6%9E%84%E5%8F%8A%E9%80%9A%E7%94%A8%E4%BB%A3%E7%A0%81/../_resources/4f06dbbf0bf44e29dcfc81ee3d40d6f8.png" alt="4f06dbbf0bf44e29dcfc81ee3d40d6f8.png"></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span>&#123;<br><span class="hljs-type">int</span> id;<br><span class="hljs-type">int</span> distFromStart;<br><span class="hljs-comment">//构造方法略</span><br>&#125;<br><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">adj</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] times,<span class="hljs-type">int</span> id)</span>&#123;<br>List&lt;Integr&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;times.length;i++)&#123;<br><span class="hljs-keyword">if</span>(times[i][<span class="hljs-number">0</span>]==id)&#123;<br>list.add(times[i][<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> list;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">weight</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] times,<span class="hljs-type">int</span> from,<span class="hljs-type">int</span> to)</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;times.length;i++)&#123;<br><span class="hljs-keyword">if</span>(times[i][<span class="hljs-number">0</span>]==from&amp;&amp;times[i][<span class="hljs-number">1</span>]==to)&#123;<br><span class="hljs-keyword">return</span> times[i][<span class="hljs-number">2</span>];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">netWorkDeplayTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] times,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k)</span>&#123;<br>Queue&lt;State&gt; pq=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;&#123;<br><span class="hljs-keyword">return</span> a.distFromStart-b.distFromStart;<br>&#125;);<br><span class="hljs-type">int</span>[] distTo=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>Arrays.fill(distTo,Integer.MAX_VALUE);<br>distTo[k]=<span class="hljs-number">0</span>;<br>pq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>(k,<span class="hljs-number">0</span>));<br><span class="hljs-keyword">while</span>(!pq.isEmpty())&#123;<br>State cur=pq.poll();<br><span class="hljs-keyword">if</span>(cur.distFromStart&gt;distTo[cur.id])&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> next:adj(times,cur.val))&#123;<br><span class="hljs-type">int</span> temp=distTo[cur.val]+weight(times,cur.val,next);<br><span class="hljs-keyword">if</span>(distTo[next]&gt;temp)&#123;<br>distTo[next]=temp;<br>pq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>(next,temp));<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(max&lt;distTo[i])&#123;<br>max=distTo[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(max==Integer.MAX_VALUE)&#123;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>遍历(BFS)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>Set&lt;Integer&gt; isVisited=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(Graph graph,<span class="hljs-type">int</span> id)</span>&#123;<br>queue.offer(id);<br>isVisited.add(id);<br><br><span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br><span class="hljs-type">int</span> sz=queue.size();<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)&#123;<br><span class="hljs-type">int</span> cur=queue.poll();<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> next:graph.get(cur))&#123;<br><span class="hljs-keyword">if</span>(!isVisited.contains(next))&#123;<br>queue.offer(next);<br>isVisited.add(next);<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/%E6%AC%A2%E8%BF%8E%EF%BC%81/1.%20Welcome%20to%20Joplin!/"/>
    <url>/2025/03/23/%E6%AC%A2%E8%BF%8E%EF%BC%81/1.%20Welcome%20to%20Joplin!/</url>
    
    <content type="html"><![CDATA[<h1 id="Welcome-to-Joplin"><a href="#Welcome-to-Joplin" class="headerlink" title="Welcome to Joplin!"></a>Welcome to Joplin!</h1><p>Joplin is a free, open source note taking and to-do application, which helps you write and organise your notes, and synchronise them between your devices. The notes are searchable, can be copied, tagged and modified either from the application directly or from your own text editor. The notes are in <a href="https://joplinapp.org/help/apps/markdown">Markdown format</a>. Joplin is available as a <strong>desktop</strong>, <strong>mobile</strong> and <strong>terminal</strong> application.</p><p>The notes in this notebook give an overview of what Joplin can do and how to use it. In general, the three applications share roughly the same functionalities; any differences will be clearly indicated.</p><p><img src="/2025/03/23/%E6%AC%A2%E8%BF%8E%EF%BC%81/1.%20Welcome%20to%20Joplin!/_resources/AllClients.png"></p><h2 id="Joplin-is-divided-into-three-parts"><a href="#Joplin-is-divided-into-three-parts" class="headerlink" title="Joplin is divided into three parts"></a>Joplin is divided into three parts</h2><p>Joplin has three main columns:</p><ul><li><p><strong>Sidebar</strong> contains the list of your notebooks and tags, as well as the synchronisation status.</p></li><li><p><strong>Note List</strong> contains the current list of notes - either the notes in the currently selected notebook, the notes in the currently selected tag, or search results.</p></li><li><p><strong>Note Editor</strong> is the place where you write your notes. There is a <strong>Rich Text editor</strong> and a <strong>Markdown editor</strong> - click on the <strong>Toggle editor</strong> button in the top right hand corner to switch between both! You may also use an <a href="https://joplinapp.org/help/apps/external_text_editor">external editor</a> to edit notes. For example you can use Typora as an external editor and it will display the note as well as any embedded images.</p></li></ul><h2 id="Writing-notes-in-Markdown"><a href="#Writing-notes-in-Markdown" class="headerlink" title="Writing notes in Markdown"></a>Writing notes in Markdown</h2><p>Markdown is a lightweight markup language with plain text formatting syntax. Joplin supports a <a href="https://joplinapp.org/help/apps/markdown">Github-flavoured Markdown syntax</a> with a few variations and additions.</p><p>In general, while Markdown is a markup language, it is meant to be human readable, even without being rendered. This is a simple example (you can see how it looks in the viewer panel):</p><hr><h1 id="Heading"><a href="#Heading" class="headerlink" title="Heading"></a>Heading</h1><h2 id="Sub-heading"><a href="#Sub-heading" class="headerlink" title="Sub-heading"></a>Sub-heading</h2><p>Paragraphs are separated by a blank line. Text attributes <em>italic</em>, <strong>bold</strong> and <code>monospace</code> are supported. You can create bullet lists:</p><ul><li>apples</li><li>oranges</li><li>pears</li></ul><p>Or numbered lists:</p><ol><li>wash</li><li>rinse</li><li>repeat</li></ol><p>This is a <a href="https://joplinapp.org/">link</a> and, finally, below is a horizontal rule:</p><hr><p>A lot more is possible including adding code samples, math formulae or checkbox lists - see the <a href="https://joplinapp.org/help/apps/markdown">Markdown documentation</a> for more information.</p><h2 id="Organising-your-notes"><a href="#Organising-your-notes" class="headerlink" title="Organising your notes"></a>Organising your notes</h2><h3 id="With-notebooks"><a href="#With-notebooks" class="headerlink" title="With notebooks"></a>With notebooks</h3><p>Joplin notes are organised into a tree of notebooks and sub-notebooks.</p><ul><li>On <strong>desktop</strong>, you can create a notebook by clicking on New Notebook, then you can drag and drop them into other notebooks to organise them as you wish.</li><li>On <strong>mobile</strong>, press the “+” icon and select “New notebook”.</li><li>On <strong>terminal</strong>, press <code>:mn</code></li></ul><p><img src="/2025/03/23/%E6%AC%A2%E8%BF%8E%EF%BC%81/1.%20Welcome%20to%20Joplin!/_resources/SubNotebooks.png"></p><h3 id="With-tags"><a href="#With-tags" class="headerlink" title="With tags"></a>With tags</h3><p>The second way to organise your notes is using tags:</p><ul><li>On <strong>desktop</strong>, right-click on any note in the Note List, and select “Edit tags”. You can then add the tags, separating them by commas.</li><li>On <strong>mobile</strong>, open the note and press the “⋮” button and select “Tags”.</li><li>On <strong>terminal</strong>, type <code>:help tag</code> for the available commands.</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/%E6%AC%A2%E8%BF%8E%EF%BC%81/2.%20Importing%20and%20exporting%20notes/"/>
    <url>/2025/03/23/%E6%AC%A2%E8%BF%8E%EF%BC%81/2.%20Importing%20and%20exporting%20notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Importing-and-exporting-notes"><a href="#Importing-and-exporting-notes" class="headerlink" title="Importing and exporting notes"></a>Importing and exporting notes</h1><h2 id="Importing-from-Evernote"><a href="#Importing-from-Evernote" class="headerlink" title="Importing from Evernote"></a>Importing from Evernote</h2><p>Joplin can import complete Evernote notebooks, as well as notes, tags, images, attached files and note metadata (such as author, geo-location, etc.) via ENEX files.</p><p>To import Evernote data, first export your Evernote notebooks to ENEX files as described <a href="https://help.evernote.com/hc/en-us/articles/209005557-How-to-back-up-export-and-restore-import-notes-and-notebooks">here</a>. Then, on <strong>desktop</strong>, do the following: Open File &gt; Import &gt; ENEX and select your file. The notes will be imported into a new separate notebook. If needed they can then be moved to a different notebook, or the notebook can be renamed, etc. Read <a href="https://joplinapp.org/help/apps/import_export#importing-from-evernote">more about Evernote import</a>.</p><h1 id="Importing-from-other-apps"><a href="#Importing-from-other-apps" class="headerlink" title="Importing from other apps"></a>Importing from other apps</h1><p>Joplin can also import notes from <a href="https://joplinapp.org/help/apps/import_export#importing-from-other-applications">many other apps</a> as well as <a href="https://joplinapp.org/help/apps/import_export#importing-from-markdown-files">from Markdown or text files</a>.</p><h1 id="Exporting-notes"><a href="#Exporting-notes" class="headerlink" title="Exporting notes"></a>Exporting notes</h1><p>Joplin can export to the JEX format (Joplin Export file), which is an archive that can contain multiple notes, notebooks, etc. This is a format mostly designed for backup purposes. You may also export to other formats such as plain Markdown files, to JSON or to PDF. Find out <a href="https://joplinapp.org/help/apps/import_export#exporting">more about exporting notes</a> on the official website.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/%E6%AC%A2%E8%BF%8E%EF%BC%81/3.%20Synchronising%20your%20notes/"/>
    <url>/2025/03/23/%E6%AC%A2%E8%BF%8E%EF%BC%81/3.%20Synchronising%20your%20notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Synchronising-your-notes"><a href="#Synchronising-your-notes" class="headerlink" title="Synchronising your notes"></a>Synchronising your notes</h1><p>Joplin allows you to synchronise your data using various file hosting services. The supported cloud services are the following:</p><h2 id="Setting-up-Joplin-Cloud-synchronisation"><a href="#Setting-up-Joplin-Cloud-synchronisation" class="headerlink" title="Setting up Joplin Cloud synchronisation"></a>Setting up Joplin Cloud synchronisation</h2><p><a href="https://joplinapp.org/plans/">Joplin Cloud</a> is a web service specifically designed for Joplin. Besides synchronising your data, it also allows you to publish a note to the internet, or share a notebook with your friends, family or colleagues. Joplin Cloud, compared to other services, also features a number of performance improvements allowing for faster synchronisation.</p><p>To use it, go to the config screen, then to the Synchronisation section. In the list of sync targets, select “Joplin Cloud”. Enter your email and password, and you’re ready to use Joplin Cloud.</p><h2 id="Setting-up-Dropbox-synchronisation"><a href="#Setting-up-Dropbox-synchronisation" class="headerlink" title="Setting up Dropbox synchronisation"></a>Setting up Dropbox synchronisation</h2><p>Select “Dropbox” as the synchronisation target in the config screen. Then, to initiate the synchronisation process, click on the “Synchronise” button in the sidebar and follow the instructions.</p><h2 id="Setting-up-Nextcloud-synchronisation"><a href="#Setting-up-Nextcloud-synchronisation" class="headerlink" title="Setting up Nextcloud synchronisation"></a>Setting up Nextcloud synchronisation</h2><p>Nextcloud is a self-hosted, private cloud solution. To set it up, go to the config screen and select Nextcloud as the synchronisation target. Then input the WebDAV URL (to get it, go to your Nextcloud page, click on Settings in the bottom left corner of the page and copy the URL). Note that it has to be the <strong>full URL</strong>, so for example if you want the notes to be under <code>/Joplin</code>, the URL would be something like <code>https://example.com/remote.php/webdav/Joplin</code> (note that “&#x2F;Joplin” part). And <strong>make sure to create the “&#x2F;Joplin” directory in Nextcloud</strong>. Finally set the username and password. If it does not work, please <a href="https://github.com/laurent22/joplin/issues/61#issuecomment-373282608">see this explanation</a> for more details.</p><h2 id="Setting-up-OneDrive-or-WebDAV-synchronisation"><a href="#Setting-up-OneDrive-or-WebDAV-synchronisation" class="headerlink" title="Setting up OneDrive or WebDAV synchronisation"></a>Setting up OneDrive or WebDAV synchronisation</h2><p>OneDrive and WebDAV are also supported as synchronisation services. Please see <a href="https://joplinapp.org/help/apps/sync/">the synchronisation documentation</a> for more information.</p><h2 id="Using-End-To-End-Encryption"><a href="#Using-End-To-End-Encryption" class="headerlink" title="Using End-To-End Encryption"></a>Using End-To-End Encryption</h2><p>Joplin supports end-to-end encryption (E2EE) on all the applications. E2EE is a system where only the owner of the data can read it. It prevents potential eavesdroppers - including telecom providers, internet providers, and even the developers of Joplin from being able to access the data. Please see the <a href="https://joplinapp.org/help/apps/sync/e2ee">End-To-End Encryption Tutorial</a> for more information about this feature and how to enable it.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/%E6%AC%A2%E8%BF%8E%EF%BC%81/4.%20Tips/"/>
    <url>/2025/03/23/%E6%AC%A2%E8%BF%8E%EF%BC%81/4.%20Tips/</url>
    
    <content type="html"><![CDATA[<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>The first few notes should have given you an overview of the main functionalities of Joplin, but there’s more it can do. See below for some of these features and how to get more help using the app:</p><h2 id="Web-clipper"><a href="#Web-clipper" class="headerlink" title="Web clipper"></a>Web clipper</h2><p><img src="/2025/03/23/%E6%AC%A2%E8%BF%8E%EF%BC%81/4.%20Tips/_resources/WebClipper.png"></p><p>The Web Clipper is a browser extension that allows you to save web pages and screenshots from your browser. To start using it, open the Joplin desktop application, go to the Web Clipper Options and follow the instructions.</p><p>More info on the official website: <a href="https://joplinapp.org/help/apps/clipper">https://joplinapp.org/help/apps/clipper</a></p><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>Joplin supports many plugins that allows you to add new features to the app, such as tabs, a table of content for your notes, a way to manage favourite notes, and many other ones. To add a plugin, go to the “Plugins” section in the config screen. From there you can search and install plugins, as well as search or update plugins.</p><h2 id="Attachments"><a href="#Attachments" class="headerlink" title="Attachments"></a>Attachments</h2><p>Any kind of file can be attached to a note. In Markdown, links to these files are represented as an ID. In the note viewer, these files, if they are images, will be displayed or, if they are other files (PDF, text files, etc.) they will be displayed as links. Clicking on this link will open the file in the default application.</p><p>Images can be attached either by clicking on “Attach file” or by pasting (with <code>Ctrl+V</code> or <code>Cmd+V</code>) an image directly in the editor, or by drag and dropping an image.</p><p>More info about attachments: <a href="https://joplinapp.org/help/apps/attachments">https://joplinapp.org/help/apps/attachments</a></p><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p>Joplin supports advanced search queries, which are fully documented on the official website: <a href="https://joplinapp.org/help/apps/search">https://joplinapp.org/help/apps/search</a></p><h2 id="Alarms"><a href="#Alarms" class="headerlink" title="Alarms"></a>Alarms</h2><p>An alarm can be associated with any to-do. It will be triggered at the given time by displaying a notification. To use this feature, see the documentation: <a href="https://joplinapp.org/help/apps/notifications">https://joplinapp.org/help/apps/notifications</a></p><h2 id="Markdown-advanced-tips"><a href="#Markdown-advanced-tips" class="headerlink" title="Markdown advanced tips"></a>Markdown advanced tips</h2><p>Joplin uses and renders <a href="https://joplinapp.org/help/apps/markdown">Github-flavoured Markdown</a> with a few variations and additions.</p><p>For example, tables are supported:</p><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><p>You can also create lists of checkboxes. These checkboxes can be ticked directly in the viewer, or by adding an “x” inside:</p><ul><li><input disabled type="checkbox"> Milk</li><li><input disabled type="checkbox"> Eggs</li><li><input checked disabled type="checkbox"> Beer</li></ul><p>Math expressions can be added using the <a href="https://khan.github.io/KaTeX/">KaTeX notation</a>:</p><p>$$<br>f(x) &#x3D; \int_{-\infty}^\infty<br>    \hat f(\xi),e^{2 \pi i \xi x}<br>    ,d\xi<br>$$</p><p>Various other tricks are possible, such as using HTML, or customising the CSS. See the Markdown documentation for more info - <a href="https://joplinapp.org/help/apps/markdown">https://joplinapp.org/help/apps/markdown</a></p><h2 id="Community-and-further-help"><a href="#Community-and-further-help" class="headerlink" title="Community and further help"></a>Community and further help</h2><ul><li>For general discussion about Joplin, user support, software development questions, and to discuss new features, go to the <a href="https://discourse.joplinapp.org/">Joplin Forum</a>. It is possible to login with your GitHub account.</li><li>The latest news are posted <a href="https://www.patreon.com/joplin">on the Patreon page</a>.</li><li>For bug reports and feature requests, go to the <a href="https://github.com/laurent22/joplin/issues">GitHub Issue Tracker</a>.</li></ul><h2 id="Donations"><a href="#Donations" class="headerlink" title="Donations"></a>Donations</h2><p>Donations to Joplin support the development of the project. Developing quality applications mostly takes time, but there are also some expenses, such as digital certificates to sign the applications, app store fees, hosting, etc. Most of all, your donation will make it possible to keep up the current development standard.</p><p>Please see the <a href="https://joplinapp.org/donate/">donation page</a> for information on how to support the development of Joplin.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/03/23/%E6%AC%A2%E8%BF%8E%EF%BC%81/5.%20Joplin%20Privacy%20Policy/"/>
    <url>/2025/03/23/%E6%AC%A2%E8%BF%8E%EF%BC%81/5.%20Joplin%20Privacy%20Policy/</url>
    
    <content type="html"><![CDATA[<h1 id="Joplin-Privacy-Policy"><a href="#Joplin-Privacy-Policy" class="headerlink" title="Joplin Privacy Policy"></a>Joplin Privacy Policy</h1><p>The Joplin applications, including the Android, iOS, Windows, macOS and Linux applications, do not send any data to any service without your authorisation. Any data that Joplin saves, such as notes or images, are saved to your own device and you are free to delete this data at any time.</p><p>If you choose to synchronise with a third-party, such as OneDrive or Dropbox, the notes will be sent to that account, in which case the third-party privacy policy applies.</p><p>In order to provide certain features, Joplin may need to connect to third-party services. You can disable most of these features in the application settings:</p><table><thead><tr><th>Feature</th><th>Description</th><th>Default</th><th>Can be disabled</th></tr></thead><tbody><tr><td>Auto-update</td><td>Joplin periodically connects to GitHub to check for new releases.</td><td>Enabled</td><td>Yes</td></tr><tr><td>Geo-location</td><td>Joplin saves geo-location information in note properties when you create a note.</td><td>Enabled</td><td>Yes</td></tr><tr><td>Synchronisation</td><td>Joplin supports synchronisation of your notes across multiple devices. If you choose to synchronise with a third-party, such as OneDrive, the notes will be sent to your OneDrive account, in which case the third-party privacy policy applies.</td><td>Disabled</td><td>Yes</td></tr><tr><td>Wifi connection check</td><td>On mobile, Joplin checks for Wifi connectivity to give the option to synchronise data only when Wifi is enabled.</td><td>Enabled</td><td>No <sup>(1)</sup></td></tr><tr><td>Spellchecker dictionary</td><td>On Linux and Windows, the desktop application downloads the spellchecker dictionary from <code>redirector.gvt1.com</code>.</td><td>Enabled</td><td>Yes <sup>(2)</sup></td></tr><tr><td>Plugin repository</td><td>The desktop application downloads the list of available plugins from the <a href="https://github.com/joplin/plugins">official GitHub repository</a>. If this repository is not accessible (eg. in China) the app will try to get the plugin list from <a href="https://github.com/laurent22/joplin/blob/8ac6017c02017b6efd59f5fcab7e0b07f8d44164/packages/lib/services/plugins/RepositoryApi.ts#L22">various mirrors</a>, in which case the plugin screen <a href="https://github.com/laurent22/joplin/issues/5161#issuecomment-925226975">works slightly differently</a>.</td><td>Enabled</td><td>No</td></tr><tr><td>Voice typing</td><td>If you use the voice typing feature on Android, the application will download the language files from <a href="https://alphacephei.com/vosk/models">https://alphacephei.com/vosk/models</a></td><td>Disabled</td><td>Yes</td></tr></tbody></table><p><sup>(1) <a href="https://github.com/laurent22/joplin/issues/5705">https://github.com/laurent22/joplin/issues/5705</a></sup><br><br><sup>(2) If the spellchecker is disabled, <a href="https://discourse.joplinapp.org/t/new-version-of-joplin-contacting-google-servers-on-startup/23000/40?u=laurent">it will not download the dictionary</a>.</sup></p><p>For any question about Joplin privacy policy, please leave a message <a href="https://discourse.joplinapp.org/">on the forum</a>.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2025/02/26/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2025/02/26/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><p><img src="/2025/02/26/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.png?v=2025022701" alt="图片引用方法二"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/02/26/hello-world/"/>
    <url>/2025/02/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
